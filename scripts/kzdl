#!/bin/sh
# SPDX-License-Identifier: 0BSD
ver='0.1.0'
set -u

# If invoked via relative path, ${exe} = the relative path.
# Otherwise, ${exe} = basename of the full path.
exe=${0}
[ -n "${exe##'/'*}" ] || exe=${exe##*'/'}

# It gives the wrong idea if a script can't print usage text or version number
# without emitting a dependency error, so we hardcode these special cases.
[ "${#}" -eq 0 ] && {
    printf 'Usage: %s [command] [options]\n%s\n' "${exe}" \
        "See \`${exe} --help\` for detailed usage information" >&2
    exit 1
}
[ "${#}" -eq 1 ] && [ "${1}" = '--version' -o "${1}" = '-V' ] && {
    printf '%s\n' "${ver}"
    exit
}

# Check if our required dependencies are present.
unset -v any_missing
for dep in 'jq' 'mktemp' 'mkfifo' 'rm'; do
    type "${dep}" >/dev/null || {
        [ -n "${any_missing+n}" ] || {
            any_missing=1
            printf 'kzdl: Missing dependencies:\n' >&2
        }
        case "${dep}" in
            'jq') printf '  jq - required for kzdl to do anything\n' >&2 ;;
            'mktemp') printf '  mktemp - required to store internal state\n' >&2 ;;
            'mkfifo') printf '  mkfifo - required to communicate with jq\n' >&2 ;;
            'rm') printf '  rm - required to clean up temporary files\n' >&2 ;;
        esac
    }
done
[ -n "${any_missing+n}" ] && exit 1

# Set up our temporary environment and jq communication pipes.
set -e
trap 'exec 3<&-; rm -rf -- "${tmpdir}"; exit 1' INT TERM
tmpdir=$(mktemp -d)
jq_stdin="${tmpdir}/jq_stdin"
jq_stdout="${tmpdir}/jq_stdout"
mkfifo -- "${jq_stdin}" "${jq_stdout}"

# Start jq background process, allowing it to drive further execution.
jq -Rr --from-file /dev/fd/3 \
    --unbuffered \
    --arg exe "${exe}" \
    --arg ver "${ver}" \
    --arg tmp "${tmpdir}" \
    --args -- "${@}" \
    <"${jq_stdin}" >"${jq_stdout}" 3<< 'JQ_SCRIPT' &
    # Read a null-terminated input string that can contain newlines.
    def read_str:
        input|until(endswith("\u0000"); . + "\n" + input)[:-1];

    # Format the input eval string such that it can be read from read -r without
    # choking on internal newlines or requiring extra processing from sh.
    def escape_eval:
        split("\n") | if length <= 1 then
            (.[0] // "") + "\n"
        else
            "eval \"$(\(
                map(@sh "printf \("%s\\n") \(.)")
                | join(";")
            ))\"\n"
        end;

    # Parse subcommands, arguments, and options.
    {
        _: {
            header: "kzdl v\($ver) - the respectful package manager",
            usage: "\($exe) [command] [options]",
            "General Options": {
                "help": {
                    usage: "--help, -h",
                    description: "print this usage info or that of a subcommand",
                },
                "version": {
                    usage: "--version, -V",
                    description: "print the current version of kzdl and exit",
                },
                "config-file": {
                    params: 1,
                    usage: "--config-file [file]",
                    description: "override the file from which kzdl loads config",
                },
            },
            short: {
                "h": "help",
                "V": "version",
            }
        },
        install: {
            header: "kzdl install - install the specified packages",
            usage: "\($exe) install [options] [packages...]",
            description: "install the specified packages",
        }
    } | { args: $ARGS.positional } |

    # Run the input shell command; set `.status` to its exit status.
    def cmd_status($cmd; f):
        $cmd, @sh "printf \("%s\\n") \"${?}\" >&3",
        (.status = (input|tonumber) | f);

    # Run the input shell command; set `.output` to its stdout.
    def cmd_output($cmd; f):
        @sh "{ eval \($cmd); printf \("\\0\\n"); } >&3",
        (.output = read_str | f);

    # Check whether $cmd exists in ${PATH}; set `.exists` to the result.
    def require_cmd($cmd; f):
        cmd_status(@sh "type \($cmd) >/dev/null"; .exists = .status == 0 | f);

    # Set `.system` to the name of the current system for download purposes.
    def uname(f):
        require_cmd("uname";
            if .exists then
                cmd_output("uname";
                    .system = (
                        .output |
                        (select(startswith("Linux"))|"linux")
                        // (select(startswith("Darwin"))|"macos")
                        // (select(startswith("Windows"))|"windows")
                        // (select(startswith("MSYS"))|"windows")
                        // (select(startswith("MINGW"))|"windows")
                        // (select(startswith("CYGWIN"))|"windows")
                        // (select(startswith("NetBSD"))|"netbsd")
                        // (select(startswith("FreeBSD"))|"freebsd")
                        // (select(startswith("OpenBSD"))|"openbsd")
                        // (select(startswith("DragonFly"))|"dragonflybsd")
                        // (select(startswith("SunOS"))|"solaris")
                        // null
                    ) | f
                )
            else
                .system = null | f
            end
        );

    # This is the main entry point for the script. Currently a random test case.
    uname(@sh "printf \("%s\\n") \(.system)"),

    # During this script's execution, kzdl and jq constantly wait on each other
    # for input. Here we close our stdin pipe and consume all inputs to ensure
    # that jq and kzdl exit gracefully instead of hanging indefinitely.
    "exec 3<&-", (inputs|empty)

    # Every output that makes it to this point is meant to be interpreted
    # directly by the shell; this filter makes it so each output corresponds
    # to exactly one `read -r` instead of being split up due to newlines.
    | escape_eval
JQ_SCRIPT
exec 3>"${jq_stdin}" 4>
printf '\n' >&3
set +e

# Eval everything the jq script tells us to.
status=0
while read -r evalstr; do
    eval "${evalstr}"
done <"${jq_stdout}"

# Clean up temporary directory and exit as appropriate.
rm -rf -- "${tmpdir}"
exit "${status}"
