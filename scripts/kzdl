#!/bin/sh
# SPDX-License-Identifier: 0BSD
main () {
    case "${0}" in
        # We are symlinked to Zig. This allows us to choose a Zig installation
        # based on environment configuration.
        'zig' | *'/zig') wrap_zig "${@}" ;;
    esac
    [ "${#}" -eq 0 ] && usage >&2 && exit 1
    [ "${1}" = '--help' ] && usage && exit
    case "${1}" in
        '--') invalid -- ;;
        '-'*) invalid option "${1}" ;;
        'run') shift && run_zig "${@}" ;;
        *) invalid command "${1}" ;;
    esac
}

usage () { printf 'Usage: %s [command] [options]\nCommands:%s' "${0}" '
  default   configure the default Zig version
  install   install a specific Zig version
  pin       create aliases and protect Zig versions from deletion
  query     list installed Zig versions and check for updates
  remove    remove specified Zig version(s)
  run       invoke Zig compiler specified by a version or alias identifier
  update    update Zig installation based on preferences
'; }

# Print an 'invalid usage' error message, with the specific text dependent
# on the provided parameter ${1} and, for some, a sub-parameter ${2}.
# ${1} possible values:
#   -- = unexpected end-of-parameter mark
#   option = unrecognized option: ${2}
#   duplicate = option specified twice: ${2}
#   command = unrecognized command: ${2}
#   missing-command = expected a command after ${2}
#   missing-value = expected a value after ${2}
#   custom = ${2}
invalid () {
    case "${1}" in
        '--') message="Unexpected end-of-parameter mark: --" ;;
        'option') message="Unrecognized option: ${2}" ;;
        'duplicate') message="Option specified twice: ${2}" ;;
        'command') message="Unrecognized command: ${2}" ;;
        'missing-command') message="Expected a command after ${2}" ;;
        'missing-value') message="Expected a value after ${2}" ;;
        'unknown-alias') message="Unrecognized version / alias identifier: ${2}" ;;
        'dangling-alias') message="Alias does not correspond to an installed version: ${2}" ;;
        'custom') message="${2}" ;;
    esac
    printf '%s\nSee `%s --help` for detailed usage information\n' "${message}" "${0}" >&2
    exit 1
}

# ${1..} = commands required to perform the requested task
# To succeed, all commands must be executable in the current environment.
# On failure, print an error message and exit.
require () {
    while [ "${#}" -gt 0 ]; do
        type "${1}" >/dev/null && shift && continue
        printf 'Command not found: %s\n' "${1}" >&2 && exit 1
    done
}

# ${1} = version or alias identifier
# On success, set the `version` variable to the canonical version corresponding
# to the provided parameter. On failure, print an error message and exit.
read_alias () {
    printf ''
}

# ${1} = Zig version / alias identifier to execute
# If the version / alias identifier resolves to an existing Zig installation,
# forward ${2..} to the Zig compiler. Otherwise, exit with an error message.
run_zig () {
    [ "${#}" -eq 0 ] && {
        printf 'Usage: %s run [version|alias] [args...]\n%s\n' "${0}" \
        '  invoke Zig compiler specified by a version or alias identifier' >&2
        exit 1
    }
    read_alias "${1}"
    [ -x "${root_path}/store/zig/${version}/${zig}" ] && {
        shift
        "${root_path}/store/zig/${version}/${zig}" "${@}"
        exit
    }
    invalid dangling-alias "${1}"
}

# If the first parameter is in the form `+[version|alias]`, the version/alias
# string will be used to select the Zig compiler. All remaining parameters,
# aside from the aforementioned special case, are forwarded directly to Zig.
wrap_zig () {
    case "${1}" in
        '+'*) version=${1#?} && shift && run_zig "${version}" "${@}" ;;
        *) run_zig default "${@}" ;;
    esac
}

# Determine the current operating system.
system=unknown
[ -n "${KZDL_SYSTEM}" ] && system=${KZDL_SYSTEM}
[ -z "${KZDL_SYSTEM}" ] && type uname >/dev/null && \
    case "$(uname)" in
        'Windows'* | 'MSYS'* | 'MINGW'* | 'CYGWIN'*) system=windows ;;
        'Darwin'*) system=macos ;;
        'NetBSD'*) system=netbsd ;;
        'FreeBSD'*) system=freebsd ;;
        'OpenBSD'*) system=openbsd ;;
        'DragonFly'*) system=dragonflybsd ;;
        'SunOS'*) system=solaris ;;
        'Linux'*) system=linux ;;
    esac
[ "${system}" = 'windows' ] && zig='zig.exe'
[ "${system}" = 'windows' ] || zig='zig'

# Determine the current architecture.
arch=unknown
[ -n "${KZDL_ARCH}" ] && arch=${KZDL_ARCH}
[ -z "${KZDL_ARCH}" ] && type uname >/dev/null && \
    case "$(uname -m)" in
        'x86_64' | 'amd64') arch=x86_64 ;;
        'x86' | 'i386' | 'i686' | 'i86pc') arch=i386 ;;
        'aarch64') arch=aarch64 ;;
        'armv6'*) arch=armv6kz ;;
        'armv7'*) arch=armv7a ;;
        'riscv64') arch=riscv64 ;;
        'sparc64' | 'sparcv9') arch=sparcv9 ;;
        'sun4u' | 'sparc') arch=sparc ;;
    esac

# Try to find an appropriate location to install everything.
if [ -n "${KZDL_ROOT}" ]; then
    root_path=${KZDL_ROOT}
elif [ -n "${XDG_DATA_HOME}" ]; then
    root_path=${XDG_DATA_HOME}/kzdl
else
    case "${system}" in
        'macos') root_path=${HOME}/Library/'Application Support'/kzdl ;;
        'windows') root_path=${LOCALAPPDATA}/kzdl ;;
        *) root_path=${HOME}/.local/share/kzdl ;;
    esac
fi

main "${@}"
