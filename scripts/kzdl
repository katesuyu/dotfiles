#!/bin/sh
# SPDX-License-Identifier: 0BSD
set -Cu
ver='0.1.0'

# Make it easier to pipe things to /dev/null.
exec 9<>/dev/null

# Programs tend to blindly attempt to write to these file descriptors and break.
[ -e /dev/fd/0 ] || exec 0<&9
[ -e /dev/fd/1 ] || exec 1>&9
[ -e /dev/fd/2 ] || exec 2>&9

# `exename` is used to behave differently depending on how we are symlinked.
# `exepath` is printed in usage text and mimics other CLIs' output text.
exename=${0##*'/'}
if exepath=$(command -v -- "${exename}" && printf 'n'); then
    [ "${exepath%?}" = "${0}" ] && exepath=${exename}
fi || exepath=${0}
exename=${0%'.sh'}

# Check for required dependencies; print error if any are missing.
type jq cat mktemp mkfifo rm >&9 || {
    # If we're invoked normally, at the very least implement the two most basic
    # CLI functions: non-argument usage text and --version.
    [ "${exename}" = 'kzdl' ] && {
        [ "${#}" -eq 0 ] && {
            printf 'Usage: %s [command] [options]\n%s\n' "${exepath}" \
                "See \`${exepath} --help\` for detailed usage information" >&2
            exit 1
        }
        [ "${#}" -eq 1 ] && [ "${1}" = '--version' -o "${1}" = '-V' ] && {
            printf '%s\n' "${ver}"
            exit
        }
    }
    # Any other functionality is too complex to implement correctly without jq.
    message=$(
        type jq >&9     || printf '\n  jq - required for all kzdl functionality'
        type cat >&9    || printf '\n  cat - required for piping file contents'
        type mktemp >&9 || printf '\n  mktemp - required to store named pipes'
        type mkfifo >&9 || printf '\n  mkfifo - required to create named pipes'
        type rm >&9     || printf '\n  rm - required to clean up temporary state'
    )
    printf 'kzdl: Missing dependencies:%s\n' "${message}"
    exit 1
}

# Set up our temporary environment and jq communication pipes.
set -e
trap 'exec 3<&-; rm -rf -- "${tmpdir}"; exit 130' INT
trap 'exec 3<&-; rm -rf -- "${tmpdir}"; exit 143' TERM
tmpdir=$(mktemp -d)
jq_stdin="${tmpdir}/jq_stdin"
jq_stdout="${tmpdir}/jq_stdout"
kzdl_internal="${tmpdir}/__internal.jq"
mkfifo -- "${jq_stdin}" "${jq_stdout}"

# Internal library module shared between the jq scripts.
cat <<'JQ_SCRIPT' >"${kzdl_internal}"
    # Run the requested filter only for non-string inputs.
    def N(f): strings // f;

    # Read the output of `cat -n` as an array of lines.
    def read_str:
        [input | while(length >= 1; input) | sub("^ *\\d+\\t"; "")];

    # Generate a printf format string that encodes the input string.
    def printf: gsub(
        "(?<percent>%)|(?<nul>\\0)|(?<newline>\\n)";
        (.newline|values|"\\n") //
        (.percent|values|"%%") //
        (.nul|values|"\\0")
    );

    # Run the input shell command; set `.status` to its exit status.
    def cmd_status($cmd):
        $cmd, @sh "printf \("%s\\n") \"${?}\" >&3",
        .status = (input|tonumber);

    # Run the input shell command; set `.output` to stdout and `.status` to exit status.
    def cmd_output($cmd):
        @sh "{ { eval \($cmd)
                printf \("\\n%s\\n") \"${?}\"
            } | cat -n; printf \("\\n")
        } >&3", (
            read_str as $str
            | .output = ($str[:-1]|join("\n"))
            | .status = ($str[-1]|tonumber)
        );

    # Check whether $cmd exists in ${PATH}; set `.exists` to the result.
    def require_cmd($cmd):
        cmd_status(@sh "type \($cmd) >&9") | N(.exists = .status == 0);

    # Prompt the user to enter 'y' or 'n'; set `.confirm` to the result.
    def prompt_user($default; $prompt; $interrupt):
        (
            if $default then " [Y/n] " else " [y/N] " end |
            @sh "{
                response=yes
                [ -t 0 ] && {
                    printf \("%s") \($prompt + .) >&2
                    IFS= read -r response
                }
                printf \("%s\\n") \"${response}\" >&3
            } <&7"
        ), (
            .confirm = (
                input? // ("\n\($interrupt)\n"|halt_error(1)) |
                if length == 0 then
                    $default
                elif test("^(?:n|no|false)$"; "i") then
                    false
                else
                    test("^(?:y|yes|true)$"; "i") // null
                end
            )
        );

    # Shorthands of the above to provide useful defaults.
    def prompt_user($default; $prompt):
        prompt_user($default; $prompt; "Interrupted!");
    def prompt_user($default):
        prompt_user($default; "Do you wish to continue?");
    def prompt_user:
        prompt_user(true);
JQ_SCRIPT

# Start jq background process, allowing it to drive further execution.
jq -Rr -L "${tmpdir}" --unbuffered \
    --from-file /dev/fd/3 \
    --arg exename "${exename}" \
    --arg exepath "${exepath}" \
    --arg tmp "${tmpdir}" \
    --arg ver "${ver}" \
    --args -- "${@}" \
    <"${jq_stdin}" >"${jq_stdout}" 3<<'JQ_SCRIPT' &
    include "__internal";

    { args: $ARGS.positional } |

    # Set `.system` to an identifier for the current system.
    def uname:
        require_cmd("uname") | N(
            if .exists then
                cmd_output("uname") | N(
                    .system = (
                        .output |
                        (select(startswith("Linux"))|"linux")
                        // (select(startswith("Darwin"))|"macos")
                        // (select(startswith("Windows"))|"windows")
                        // (select(startswith("MSYS"))|"windows")
                        // (select(startswith("MINGW"))|"windows")
                        // (select(startswith("CYGWIN"))|"windows")
                        // (select(startswith("NetBSD"))|"netbsd")
                        // (select(startswith("FreeBSD"))|"freebsd")
                        // (select(startswith("OpenBSD"))|"openbsd")
                        // (select(startswith("DragonFly"))|"dragonflybsd")
                        // (select(startswith("SunOS"))|"solaris")
                        // null
                    )
                )
            else
                .system = null
            end
        );

    # Script entry point; current just a testbed for the above functions.
    def main:
        uname | N(prompt_user) | N(
            if .confirm then
                @sh "printf \("Your system is: %s\\n") \(.system) >&2"
            else
                @sh "printf \("Canceled!\\n") >&2"
            end
        );
    main, "exec 3<&-" | printf
JQ_SCRIPT

exec 3>"${jq_stdin}"
printf '\n' >&3
set +e

# Eval everything the jq script tells us to.
status=0
while IFS= read -r evalstr; do
    eval "$(printf "%s${evalstr}" '')"
done 7<&0 <"${jq_stdout}"

# Clean up temporary directory and exit as appropriate.
rm -rf -- "${tmpdir}"
exit "${status}"
