#!/bin/sh
# SPDX-License-Identifier: 0BSD

# Determine system, load config file into memory, and parse options and parameters.
main () {
    # Find the current system if `uname` is available.
    unset -v system
    type uname >/dev/null && \
        case "$(uname)" in
            'Windows'* | 'MSYS'* | 'MINGW'* | 'CYGWIN'*) system=windows ;;
            'Darwin'*) system=macos ;;
            'NetBSD'*) system=netbsd ;;
            'FreeBSD'*) system=freebsd ;;
            'OpenBSD'*) system=openbsd ;;
            'DragonFly'*) system=dragonflybsd ;;
            'SunOS'*) system=solaris ;;
            'Linux'*) system=linux ;;
        esac

    if [ -n "${XDG_CONFIG_HOME+n}" ]; then
        # This is the most appropriate config location on Linux, and
        # it doesn't do any harm to check here on other OSes.
        config_path="${XDG_CONFIG_HOME}/kzdl/kzdl.json"
    elif [ -n "${LOCALAPPDATA+n}" ] && [ "${system-windows}" = 'windows' ]; then
        # If we find this environment variable, and `uname` didn't tell us we
        # were on a different OS (env var could leak into WSL or something),
        # use ${LOCALAPPDATA} to store configuration.
        system=windows
        config_path="${LOCALAPPDATA}/kzdl/kzdl.json"
    elif [ "${system}" = 'macos' ]; then
        # This is the recommended location for macOS config; a lot of macOS
        # users do not like their ${HOME} being cluttered with dotfiles.
        config_path="${HOME}/Library/Application Support/kzdl/kzdl.json"
    else
        # Either we don't know the operating system, we don't know the canonical
        # location for config on the operating system, or it's Linux and the
        # user did not specify ${XDG_CONFIG_HOME}.
        config_path="${HOME}/.config/kzdl/kzdl.json"
    fi

    # Retrieve config file if we're able to read it.
    unset -v config_err
    { [ -f "${config_path}" ] && type jq >/dev/null && \
        config=$(export config_path; jq -c '
            if isempty(input?)|not then
                "Config file has multiple root objects
                Check \($ENV.config_path)\n"|halt_error
            elif type != "object"
                "Config file has non-object root value: \(type)
                Check \($ENV.config_path)\n"|halt_error
            else . end
        ' -- "${config_path}")
    } || {
        # `[ ... ]` and `type` return 1 on failure.
        # jq returns 2, 3, or 5 on failure.
        # We only want to set this variable if jq failed.
        [ "${?}" -ge 2 ] config_err=${?}
        unset -v config
    }

    case "${0}" in
        # We have been invoked as `zig`. Wrap the default compiler but allow
        # the version to be overriden with the syntax `zig +[version] ...`
        'zig' | *'/zig' | 'zig.sh' | *'/zig.sh')
            wrap_zig "${@}" ;;
    esac

    # Invoke argument parsing, which uses `eval` to reorder positional arguments,
    # set variables to appropriate values, and invoke the requested subcommand.
    [ "${#}" -eq 0 ] && invalid usage '[command] [options]' >&2 && exit 1
    parse_args && eval "${eval_string}"
}

# Print an 'invalid usage' error message, with the specific text dependent
# on the provided parameters ${1} and ${2}
invalid () {
    case "${1}" in
        'end-of-option' message="End-of-option mark '--' must follow a subcommand" ;;
        'usage') message="Usage: ${0} ${2}" ;;
        'option') message="Unrecognized option: ${2}" ;;
        'ill-formed') message="Ill-formed parameter: ${2}" ;;
        'duplicate') message="Option specified twice: ${2}" ;;
        'subcommand') message="Unrecognized subcommand: ${2}" ;;
        'missing-command') message="Expected a command after ${2}" ;;
        'missing-value') message="Expected a value after ${2}" ;;
        'unknown-alias') message="Unrecognized compiler alias: ${2}" ;;
        'unknown-version') message="Unrecognized compiler version: ${2}" ;;
        'dangling-alias') message="Alias does not correspond to an installed version: ${2}" ;;
        'custom') message="${2}" ;;
        *) message="Internal error: ${1}: ${2}"
    esac
    printf '%s\nSee `%s --help` for detailed usage information\n' "${message}" "${0}" >&2
    exit 1
}

# Usage text describing the available subcommands and options.
usage () { printf 'kzdl v0.1.0 - configurable Zig version multiplexer

Usage: %s [command] [options]\n\nCommands:%s' "${0}" '
  clean
    clean unused Zig versions based on configured cleaning policy

  config
    update kzdl configuration from the command line

  install
    install the specified Zig version

  query
    list installed Zig versions and check for updates

  remove
    remove specified Zig version(s)

  run
    invoke Zig compiler specified by a version or alias identifier

  update
    update Zig installation based on preferences

Options:
'"${basic_options}"'
'; }

# Basic set of options available for every subcommand.
basic_options='
  --help, -h
    print this usage info or that of a subcommand

  --version, -V
    print the current version of kzdl and exit

  --verbose, -v
    print more verbose output when performing tasks

  --interactive, -i
    ask for confirmation before modifying files on disk

  --force, -f
    do not ask for confirmation before modifying files on disk
'
basic_options=${basic_options#?}
basic_options=${basic_options%?}

# Parse arguments and output a string to be evaluated by the shell to reorder
# arguments and variables as necessary and then run the requested subcommand.
parse_args () {
    index=1
    unset -v end_of_option
    unset -v subcommand
    unset -v opt_help
    unset -v opt_version
    unset -v opt_verbose
    unset -v opt_interactive
    unset -v opt_force
    unset -v positional
    unset -v eval_string
    while [ "${#}" -gt 0 ]; do
        if [ "${end_of_option}" = 1 ]; then
            positional=${positional}${positional+ }${index}
        else
            case "${1}" in
                '--') [ -z "${end_of_option+n}" ] && invalid end-of-option
                    end_of_option=1 ;;
                '---'*) invalid ill-formed "${1}" ;;
                '--'*) parse_long_option "${@}" ;;
                '-'*) parse_short_option "${@}" ;;
                *) if [ -z "${subcommand+n}" ]; then
                    verify_subcommand "${1}"
                else
                    positional=${positional}${positional+ }${index}
                fi ;;
            esac
        fi
        shift
        index=$((index + 1))
    done
    # Now that we have all the options in variables, this removes all options
    # and option payloads from ${@}, giving subcommands the freedom to access
    # positional arguments directly.
    eval_string=$(
        printf 'set --'
        for i in ${positional}; do
            printf ' "${%s}"' "${i}"
        done
    )
}

# Parse short option clusters and their payloads.
parse_short_option () {
    true
}

# Parse long options and their payloads.
parse_long_option () {
    true
}

# Check if the subcommand ${1} exists and exit if not.
verify_subcommand () {
    case "${1}" in
        'clean' | 'config' | 'install' | \
        'query' | 'run' | 'remove' | 'update') subcommand=${1} ;;
        'version') invalid subcommand "${1}"'
Use `'"${0}"' --version` to query current version' ;;
        *) invalid subcommand "${1}" ;;
    esac
    [ -n "${config_err+n}" ] && [ "${1}" != 'config' ] && {
        invalid custom 'Cannot run subcommands other than `config` with config errors
        Run `'"${1}"' config reset` or fix the errors in '"${config_path}"
    }
}

# Keep the first ${1} characters from ${2}.
# Result is available in ${trimmed}.
keep_first () {
    [ "${1}" -ge "${#2}" ] && {
        trimmed=${2}
        return
    }
    remove_last "$((${#2} - ${1}))" "${2}"
}

# Keep the final ${1} characters from ${2}.
# Result is available in ${trimmed}.
keep_last () {
    [ "${1}" -ge "${#2}" ] && {
        trimmed=${2}
        return
    }
    remove_first "$((${#2} - ${1}))" "${2}"
}

# Remove the final ${1} characters from the end of ${2}.
# Result is available in ${trimmed}.
remove_last () {
    while [ "${1}" -ge 16 ]; do
        set -- "$((${1} - 16))" "${2%????????????????}"
    done
    while [ "${1}" -ge 4 ]; do
        set -- "$((${1} - 4))" "${2%????}"
    done
    while [ "${1}" -gt 0 ]; do
        set -- "$((${1} - 1))" "${2%?}"
    done
    trimmed=${2}
}

# Remove the first ${1} characters from the end of ${2}.
# Result is available in ${trimmed}.
remove_first () {
    while [ "${1}" -ge 16 ]; do
        set -- "$((${1} - 16))" "${2#????????????????}"
    done
    while [ "${1}" -ge 4 ]; do
        set -- "$((${1} - 4))" "${2#????}"
    done
    while [ "${1}" -gt 0 ]; do
        set -- "$((${1} - 1))" "${2#?}"
    done
    trimmed=${2}
}

# ${1..} = commands required to perform the requested task
# To succeed, all commands must be executable in the current environment.
# On failure, print an error message and exit.
require () {
    while [ "${#}" -gt 0 ]; do
        type "${1}" >/dev/null && shift && continue
        printf 'Command not found: %s\n' "${1}" >&2
        exit 1
    done
}

# Append a filler character to avoid newline trimming upon command substitution.
safesub () {
    "${@}" || return
    printf '.'
}

# Retrieve the requested value from config JSON, returning a default if the
# value was not present in the config JSON.
get_config () {
    true
}

# ${1} = version or alias identifier
# On success, set the `version` variable to the canonical version corresponding
# to the provided parameter. On failure, print an error message and exit.
read_alias () {
    true
}

# ${1} = Zig version / alias identifier to execute
# If the version / alias identifier resolves to an existing Zig installation,
# forward ${2..} to the Zig compiler. Otherwise, exit with an error message.

# If the first parameter is in the form `+[version|alias]`, the version/alias
# string will be used to select the Zig compiler. All remaining parameters,
# aside from the aforementioned special case, are forwarded directly to Zig.
wrap_zig () {
    case "${1}" in
        '+'*) version=${1#?} && shift && run "${version}" "${@}" ;;
        *) run default "${@}" ;;
    esac
}

# Remove unused Zig versions from subscribed channels, excluding specific versions
# that may have been pinned. The precise cleaning policy is user-configurable.
clean () {
    printf 'Not yet implemented\n' >&2 && exit 1
}

# Configure the default version of Zig. This is a convenience shortcut equivalent
# to using `kzdl pin` to assign the `default` alias to a version or channel.
default () {
    printf 'Not yet implemented\n' >&2 && exit 1
}

# Install Zig toolchains and subscribe to updates for stable/nightly.
install () {
    usage () { printf 'Usage: %s install [options] [channel]\n\nChannels:\n%s\n\nOptions:%s' "${0}" "$(
        set -f
        IFS=:
        for channel in ${channels}; do
            printf '  %s\n' "${channel}"
        done
    )" '
  --once         retrieve a single version from the channel without subscribing to it
  --pin [name]   pin the target with the provided string as an alias
  --pin-date     pin the target with its build date as an alias
  --pin-version  pin the target with its version as an alias
  --temp [name]  assign the target an alias but do not pin it
  --version      the channel parameter instead takes a version number
';  }
    [ "${#}" -eq 0 ] && usage >&2 && exit 1
    [ "${1}" = '--help' ] && usage && exit
    exit
}

# Create aliases to a specific version or channel of Zig, and pin versions to
# protect them from `kzdl clean` or `kzdl update` (depending on configuration).
pin () {
    printf 'Not yet implemented\n' >&2 && exit 1
}

# Query if the provided channel (or any subscribed channels, if no argument is
# provided) has an update available, returning the version if so.
query () {
    printf 'Not yet implemented\n' >&2 && exit 1
}

# Remove the specified Zig version. If the target is a channel, removes the
# implicit pin on the configured amount of versions, and by default also
# removes those installations if no pins remain.
remove () {
    printf 'Not yet implemented\n' >&2 && exit 1
}

# Forward arguments to the Zig compiler identified by the provided alias.
run () {
    [ "${#}" -eq 0 ] && {
        printf 'Usage: %s run [alias] [args...]\n' "${0}" >&2
        exit 1
    }
    read_alias "${1}"
    [ -x "${folder}/zig" ] && {
        shift
        "${folder}/zig" "${@}"
        exit
    }
    invalid dangling-alias "${1}"
}

# Update the specified channel, or all subscribed channels if no argument is provided.
# If configured to do so, may automatically trigger a clean once updated.
update () {
    printf 'Not yet implemented\n' >&2 && exit 1
}

main "${@}"
