#!/bin/sh
# SPDX-License-Identifier: 0BSD
set -u
ver='0.1.0'

# Make it easier to pipe things to /dev/null.
exec 9<>/dev/null

# Programs tend to blindly attempt to write to these file descriptors and break.
[ -e /dev/fd/0 ] || exec 0<&9
[ -e /dev/fd/1 ] || exec 1>&9
[ -e /dev/fd/2 ] || exec 2>&9

# `exename` is used to behave differently depending on how we are symlinked.
# `exepath` is printed in usage text and mimics other CLIs' output text.
exename=${0##*'/'}
if exepath=$(command -v -- "${exename}" && printf 'n'); then
    [ "${exepath%?}" = "${0}" ] && exepath=${exename}
fi || exepath=${0}
exename=${0%'.sh'}

# Check for required dependencies; print error if any are missing.
type jq cat mktemp mkfifo rm >&9 || {
    # If we're invoked normally, at the very least implement the two most basic
    # CLI functions: non-argument usage text and --version.
    [ "${exename}" = 'kzdl' ] && {
        [ "${#}" -eq 0 ] && {
            printf 'Usage: %s [command] [options]\n%s\n' "${exepath}" \
                "See \`${exepath} --help\` for detailed usage information" >&2
            exit 1
        }
        [ "${#}" -eq 1 ] && [ "${1}" = '--version' -o "${1}" = '-V' ] && {
            printf '%s\n' "${ver}"
            exit
        }
    }
    # Any other functionality is too complex to implement correctly without jq.
    message=$(
        type jq >&9     || printf '\n  jq - required for all kzdl functionality'
        type cat >&9    || printf '\n  cat - required for piping file contents'
        type mktemp >&9 || printf '\n  mktemp - required to store named pipes'
        type mkfifo >&9 || printf '\n  mkfifo - required to create named pipes'
        type rm >&9     || printf '\n  rm - required to clean up temporary state'
    )
    printf 'kzdl: Missing dependencies:%s\n' "${message}"
    exit 1
}

# Set up our temporary environment and jq communication pipes.
set -e
trap 'exec 3<&-; rm -rf -- "${tmpdir}"; exit 130' INT
trap 'exec 3<&-; rm -rf -- "${tmpdir}"; exit 143' TERM
tmpdir=$(mktemp -d)
jq_stdin="${tmpdir}/jq_stdin"
jq_stdout="${tmpdir}/jq_stdout"
kzdl_internal="${tmpdir}/__internal.jq"
mkfifo -- "${jq_stdin}" "${jq_stdout}"

# Internal library module shared between the jq scripts.
cat <<'JQ_SCRIPT' >"${kzdl_internal}"
    # Read the output of `cat -n` as an array of lines.
    def read_str:
        [input | while(length >= 1; input) | sub("^ *\\d+\\t"; "")];

    # Takes an eval string with one or more lines and produces an equivalent
    # eval string that fits on one line (can be read with `read -r`).
    def escape_eval:
        split("\n") | if length <= 1 then
            .[0] + "\n"
        else
            ("%s\\n" * length | @sh)
            + " \(map(@sh)|join(" "))"
            | "eval \"$(printf \(.))\"\n"
        end;

    # Run the input shell command; set `.status` to its exit status.
    def cmd_status($cmd; f):
        $cmd, @sh "printf \("%s\\n") \"${?}\" >&3",
        (.status = (input|tonumber) | f);

    # Run the input shell command; set `.output` to its stdout.
    def cmd_output($cmd; f):
        @sh "{ { eval \($cmd)
                printf \("\\n%s\\n") \"${?}\"
            } | cat -n; printf \("\\n")
        } >&3", (
            read_str as $str
            | .output = ($str[:-1]|join("\n"))
            | .status = ($str[-1]|tonumber)
            | f
        );

    # Check whether $cmd exists in ${PATH}; set `.exists` to the result.
    def require_cmd($cmd; f):
        cmd_status(@sh "type \($cmd) >&9"; .exists = .status == 0 | f);

    # Prompt the user to enter 'y' or 'n'; set `.confirm` to the result.
    def prompt_user($default; $prompt; f):
        (
            if $default then " [Y/n] " else " [y/N] " end |
            @sh "{
                response=yes
                [ -t 0 ] && {
                    printf \("%s") \($prompt + .) >&2
                    IFS= read -r response
                }
                printf \("%s\\n") \"${response}\" >&3
            } <&7"
        ), (
            .confirm = (
                input? // ("\nInterrupted!\n"|halt_error(1)) |
                if length == 0 then
                    $default
                elif test("^(?:n|no|false)$"; "i") then
                    false
                else
                    test("^(?:y|yes|true)$"; "i") // null
                end
            ) | f
        );

    # Shorthands of the above to provide useful defaults.
    def prompt_user($default; f):
        prompt_user($default; "Do you wish to continue?"; f);
    def prompt_user(f):
        prompt_user(true; f);
JQ_SCRIPT

# Start jq background process, allowing it to drive further execution.
jq -Rr -L "${tmpdir}" --unbuffered \
    --from-file /dev/fd/3 \
    --arg exename "${exename}" \
    --arg exepath "${exepath}" \
    --arg tmp "${tmpdir}" \
    --arg ver "${ver}" \
    --args -- "${@}" \
    <"${jq_stdin}" >"${jq_stdout}" 3<<'JQ_SCRIPT' &
    include "__internal";

    { args: $ARGS.positional } |

    # Set `.system` to an identifier for the current system.
    def uname(f):
        require_cmd("uname";
            if .exists then
                cmd_output("uname";
                    .system = (
                        .output |
                        (select(startswith("Linux"))|"linux")
                        // (select(startswith("Darwin"))|"macos")
                        // (select(startswith("Windows"))|"windows")
                        // (select(startswith("MSYS"))|"windows")
                        // (select(startswith("MINGW"))|"windows")
                        // (select(startswith("CYGWIN"))|"windows")
                        // (select(startswith("NetBSD"))|"netbsd")
                        // (select(startswith("FreeBSD"))|"freebsd")
                        // (select(startswith("OpenBSD"))|"openbsd")
                        // (select(startswith("DragonFly"))|"dragonflybsd")
                        // (select(startswith("SunOS"))|"solaris")
                        // null
                    ) | f
                )
            else
                .system = null | f
            end
        );

    # Script entry point; current just a testbed for the above functions.
    uname(prompt_user(
        if (.confirm) then
            @sh "printf \("Your system is: %s\\n") \(.system) >&2"
        else
            empty
        end
    )),

    # Close stdin pipe so jq won't block forever; then, ignore remaining input.
    "exec 3<&-", (inputs|empty)

    # Every output that makes it to this point is meant to be interpreted
    # directly by the shell; this filter makes it so each output corresponds
    # to exactly one `read -r` instead of being split up due to newlines.
    | escape_eval
JQ_SCRIPT

exec 3>"${jq_stdin}"
printf '\n' >&3
set +e

# Eval everything the jq script tells us to.
status=0
while IFS= read -r evalstr; do
    eval "${evalstr}"
done 7<&0 <"${jq_stdout}"

# Clean up temporary directory and exit as appropriate.
rm -rf -- "${tmpdir}"
exit "${status}"
