#!/bin/sh
# SPDX-License-Identifier: 0BSD

# Determine system, load config file into memory, and parse options and parameters.
main () {
    # Find the current system if `uname` is available.
    unset -v system
    type uname >/dev/null && \
        case "$(uname)" in
            'Windows'* | 'MSYS'* | 'MINGW'* | 'CYGWIN'*) system=windows ;;
            'Darwin'*) system=macos ;;
            'NetBSD'*) system=netbsd ;;
            'FreeBSD'*) system=freebsd ;;
            'OpenBSD'*) system=openbsd ;;
            'DragonFly'*) system=dragonflybsd ;;
            'SunOS'*) system=solaris ;;
            'Linux'*) system=linux ;;
        esac

    # Search this path for a config file in case the user does not realize
    # we use the XDG / APPDATA / Application Support paths by default.
    fallback_config_path="${HOME}/.config/kzdl/kzdl.json"
    fallback_config_path2="${HOME}/.config/kzdl.json"

    # Find the system-dependent location to place config files.
    if [ -n "${XDG_CONFIG_HOME+n}" ]; then
        # This is the most appropriate config location on Linux, and
        # it doesn't do any harm to check here on other OSes.
        default_config_path="${XDG_CONFIG_HOME}/kzdl/kzdl.json"
        default_config_path2="${XDG_CONFIG_HOME}/kzdl.json"
    elif [ -n "${APPDATA+n}" ] && [ "${system-windows}" = 'windows' ]; then
        # If we find this environment variable, and `uname` didn't tell us we
        # were on a different OS (env var could leak into WSL or something),
        # use ${APPDATA} to store configuration.
        system=windows
        default_config_path="${APPDATA}/kzdl/kzdl.json"
        default_config_path2="${APPDATA}/kzdl.json"
    elif [ "${system}" = 'macos' ]; then
        # This is the recommended location for macOS config; a lot of macOS
        # users do not like their ${HOME} being cluttered with dotfiles.
        default_config_path="${HOME}/Library/Application Support/kzdl/kzdl.json"
        default_config_path2="${HOME}/Library/Application Support/kzdl.json"
    else
        # Either we don't know the operating system, we don't know the canonical
        # location for config on the operating system, or it's Linux and the
        # user did not specify ${XDG_CONFIG_HOME}.
        default_config_path=${fallback_config_path}
        default_config_path2=${fallback_config_path2}
        unset -v fallback_config_path
        unset -v fallback_config_path2
    fi

    case "${0}" in
        # We have been invoked as `zig`. Wrap the default compiler but allow
        # the version to be overriden with the syntax `zig +[version] ...`
        'zig' | *'/zig' | 'zig.sh' | *'/zig.sh')
            wrap_zig "${@}" ;;
    esac

    # Extract options into variables while removing them from `${@}`.
    parse_args "${@}" && eval "${eval_string}"

    # Be a bit silly if --help is specified 3 or more times.
    case "${opt_help}" in
        '' | [1-2]) unset -v usage_header ;;
        [3-6]) usage_header="Here is your usage info, as requested ${opt_help} times..." ;;
        *) usage_header="Do you really need help? I'm sorry, I can't tell.
It's not like you requested it ${opt_help} times or anything..." ;;
    esac

    # Handle --help, --version, and invoking `kzdl` with no subcommand.
    [ -n "${opt_help+n}" ] && \
        case "${subcommand}" in
            '') main_usage && exit ;;
            'install') install_usage && exit ;;
            *) invalid todo "usage for subcommand ${subcommand}" ;;
        esac
    [ -n "${opt_version+n}" ] && printf '0.1.0\n' && exit
    [ -z "${subcommand+n}" ] && invalid usage '[command] [options]'

    # Check whether we can read the config file.
    unset -v config_err
    if [ -n "${opt_config_path+n}" ]; then
        config_path=${opt_config_path}
        [ -f "${config_path}" ]
    else
        config_path=${default_config_path}
        [ -f "${config_path}" ] || {
            [ -f "${default_config_path2}" ] && \
            config_path=${default_config_path2}
        } || {
            [ -n "${fallback_config_path+n}" ] && \
            [ -f "${fallback_config_path}" ] && \
            config_path=${fallback_config_path}
        } || {
            [ -n "${fallback_config_path2+n}" ] && \
            [ -f "${fallback_config_path2}" ] && \
            config_path=${fallback_config_path2}
        }
    fi

    # Retrieve config data if the above checks succeeded and we have `jq`.
    { [ "${?}" -eq 0 ] && type jq >/dev/null && \
        config=$(export config_path; jq -c '
            if isempty(input?)|not then
                "Config file has multiple root objects
                Check \($ENV.config_path)\n"|halt_error
            elif type != "object"
                "Config file has non-object root value: \(type)
                Check \($ENV.config_path)\n"|halt_error
            else . end
        ' -- "${config_path}")
    } || {
        # We only care about `jq` errors (2, 3, or 5).
        # `[ ]` and `type` only return errors of 1.
        case "${?}" in
            [!1]) config_err=${?} ;;
        esac
        unset -v config
    }
}

# Print an 'invalid usage' error message, with the specific text dependent
# on the provided parameter ${1} (which can reference ${2} or ${3}).
invalid () {
    case "${1}" in
        'end-of-option') message="End-of-option mark '--' must follow a subcommand" ;;
        'usage') message="Usage: ${0} ${2}" ;;
        'option') message="Bad option string: ${2}" ;;
        'subcommand') message="Unrecognized subcommand: ${2}" ;;
        'argument-value') message="Option does not take argument: ${2}" ;;
        'missing-command') message="Expected a command after ${2}" ;;
        'missing-value') message="Expected a value after option: ${2}" ;;
        'unknown-option') message="Unrecognized option: ${2}" ;;
        'unknown-alias') message="Unrecognized compiler alias: ${2}" ;;
        'unknown-version') message="Unrecognized compiler version: ${2}" ;;
        'dangling-alias') message="Alias does not correspond to an installed version: ${2}" ;;
        'custom') message="${2}" ;;
        *) message="Internal error: ${1}: ${2}" ;;
    esac
    printf '%s\nSee `%s --help` for detailed usage information\n' "${message}" "${0}" >&2
    exit 1
}

# Usage text describing the available subcommands and options.
main_usage () {
usage_header=${usage_header-'kzdl v0.1.0 - configurable Zig version multiplexer'}
printf '%s\n
Usage: %s [command] [options]\n\nCommands:%s' "${usage_header}" "${0}" '
  install
    install the specified versions of Zig

  update
    update Zig installations based on preferences

  remove
    remove specified Zig versions

  clean
    clean unused Zig versions based on configured cleaning policy

  config
    update kzdl configuration from the command line

  query
    list installed Zig versions and check for updates

  run
    invoke Zig compiler specified by a version or alias identifier

General Options:
'"${general_options}"'
'; }

install_usage () {
usage_header=${usage_header-'kzdl install - install the specified versions of Zig'}
printf '%s\n
Usage: %s install [options] [versions...]\n\nVersions:%s' "${usage_header}" "${0}" '
  master
    the latest CI build available from ziglang.org

  stable
    the latest official version as listed on ziglang.org

  [X.Y.Z] (0.6.0)
    a specific version provided in semver notation

  [X.Y.Z+hash] (0.6.0+bd449b184)
    a specific post-X.Y.Z development version, identified by commit hash

Install Options:
  --alias=[name], -a [name]
    configure an alias for the installed Zig version

  --date-alias
    use the installed Zig version'\''s build date as an alias

  --store-root=[dir], -R [dir]
    override the folder in which all Zig versions are installed

  --output-dir=[dir]
    override the folder in which a specific Zig version is unpacked

  --os=[name]
    the operating system upon which the downloaded versions should run

  --arch=[name]
    the CPU architecture upon which the downloaded versions should run

General Options:
'"${general_options}"'
'; }

# Basic set of options available for every subcommand.
general_options='
  --help, -h
    print this usage info or that of a subcommand

  --version, -V
    print the current version of kzdl and exit

  --verbose, -v
    print more verbose output when performing tasks

  --interactive, -i
    ask for confirmation before modifying files on disk

  --force, -f
    do not ask for confirmation before modifying files on disk

  --config-file=[file]
    override the file from which configuration is loaded

  -- (end-of-options mark)
    suppress option parsing for further arguments
'
general_options=${general_options#?}
general_options=${general_options%?}

# Fully parse the arguments, correctly categorizing options, option payloads,
# and subcommands. Sets `eval_string` to a correctly quoted `set --` command
# that removes all arguments except for non-option positional parameters.
parse_args () {
    eval_string='set --'
    true_index=1 # `${N}` to use in `eval_string`.
    logical_index=1 # `${N}` which is valid post-eval.
    shift_amount=1 # Amount to shift per iteration.
    unset -v end_of_option
    unset -v subcommand
    unset -v opt_help
    unset -v opt_version
    unset -v opt_verbose
    unset -v opt_interactive
    unset -v opt_force
    unset -v opt_config_path
    while [ "${#}" -gt 0 ]; do
        if [ -n "${end_of_option+n}" ]; then
            # Add the index of this non-option positional parameter.
            eval_string="${eval_string}"' "${'"${true_index}"'}"'
        else
            case "${1}" in
                '--') [ -z "${subcommand+n}" ] && invalid end-of-option
                    end_of_option=1 ;;
                '---'*) invalid option "${1}" ;;
                '--'*) parse_long_option "${@}" ;;
                '-'?*) parse_short_option "${@}" ;;
                *) if [ -z "${subcommand+n}" ]; then
                    case "${1}" in
                        'clean' | 'config' | 'install' | \
                        'query' | 'run' | 'remove' | 'update') subcommand=${1} ;;
                        *) invalid subcommand "${1}" ;;
                    esac
                else
                    # Add the index of this non-option positional parameter.
                    eval_string="${eval_string}"' "${'"${true_index}"'}"'
                    # Maintain a correct index for options that reference positions.
                    logical_index=$((logical_index + 1))
                fi ;;
            esac
        fi
        shift "${shift_amount}"
        true_index=$((${true_index} + ${shift_amount}))
        shift_amount=1 # Shift amounts != 1 only apply for a single iteration.
    done
}

# Parse short option clusters and their values. Sets `shift_amount` to
# a higher value as appropriate for any values the option may have taken.
parse_short_option () {
    cluster=${1#?}
    case "${cluster}" in
        *[!a-zA-Z0-9]*) invalid option "${1}" ;;
    esac
    while [ "${#cluster}" -gt 0 ]; do
        case "${cluster}" in
            h*) opt_help=$((${opt_help-0} + 1)) ;;
            V*) opt_version=1 ;;
            v*) opt_verbose=$((${opt_verbose-0} + 1)) ;;
            i*) opt_interactive=1
                unset -v opt_force ;;
            f*) opt_force=1
                unset -v opt_interactive ;;
            *) keep_first 1 "${cluster}"
                invalid unknown-option "-${trimmed}" ;;
        esac
        cluster=${cluster#?}
    done
}

# Parse long options and their values, handling both `key=value` and
# `key` `value` forms as appropriate. Sets `shift_amount` to a higher
# value as appropriate for any values the option may have taken.
parse_long_option () {
    # Parse both "conjoined" key=value and separate ${key} ${value}. Track
    # information required to emit missing value errors.
    case "${1}" in
        *'='*) long_opt_conjoined=1
            long_opt_key=${1%%'='*}
            long_opt_key=${long_opt_key#'--'}
            long_opt_value=${1#*'='} ;;
        *) unset -v long_opt_conjoined
            long_opt_key=${1#'--'}
            long_opt_value=${2} ;;
    esac
    case "${long_opt_key}" in
        'help' | 'version' | 'verbose' | \
        'interactive' | 'force')
            [ -n "${long_opt_conjoined+n}" ] && invalid argument-value "${1}" ;;
        'config-file')
            [ -z "${long_opt_conjoined+n}" ] && {
                [ -z "${2+n}" ] && invalid missing-value "${1}"
                shift_amount=2
            } ;;
        *[!a-zA-Z0-9_-]*) invalid option "${1}" ;;
        *) invalid unknown-option "--${long_opt_key}" ;;
    esac
    case "${long_opt_key}" in
        'help') opt_help=$((${opt_help-0} + 1)) ;;
        'version') opt_version=1 ;;
        'verbose') opt_verbose=$((${opt_verbose-0} + 1)) ;;
        'interactive') opt_interactive=1
            unset -v opt_force ;;
        'force') opt_force=1
            unset -v opt_interactive ;;
        'config-file') opt_config_path=${long_opt_value} ;;
    esac
}

# Keep the first ${1} characters from ${2}.
# Result is available in ${trimmed}.
keep_first () {
    [ "${1}" -ge "${#2}" ] && {
        trimmed=${2}
        return
    }
    remove_last "$((${#2} - ${1}))" "${2}"
}

# Keep the final ${1} characters from ${2}.
# Result is available in ${trimmed}.
keep_last () {
    [ "${1}" -ge "${#2}" ] && {
        trimmed=${2}
        return
    }
    remove_first "$((${#2} - ${1}))" "${2}"
}

# Remove the final ${1} characters from the end of ${2}.
# Result is available in ${trimmed}.
remove_last () {
    while [ "${1}" -ge 16 ]; do
        set -- "$((${1} - 16))" "${2%????????????????}"
    done
    while [ "${1}" -ge 4 ]; do
        set -- "$((${1} - 4))" "${2%????}"
    done
    while [ "${1}" -gt 0 ]; do
        set -- "$((${1} - 1))" "${2%?}"
    done
    trimmed=${2}
}

# Remove the first ${1} characters from the end of ${2}.
# Result is available in ${trimmed}.
remove_first () {
    while [ "${1}" -ge 16 ]; do
        set -- "$((${1} - 16))" "${2#????????????????}"
    done
    while [ "${1}" -ge 4 ]; do
        set -- "$((${1} - 4))" "${2#????}"
    done
    while [ "${1}" -gt 0 ]; do
        set -- "$((${1} - 1))" "${2#?}"
    done
    trimmed=${2}
}

main "${@}"
