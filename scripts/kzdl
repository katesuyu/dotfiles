#!/bin/sh
# SPDX-License-Identifier: 0BSD
set -Cu
ver='0.1.0'

# Make it easier to pipe things to /dev/null.
exec 9<>/dev/null

# Programs tend to blindly attempt to write to these file descriptors and break.
[ -e /dev/fd/0 ] || exec 0<&9
[ -e /dev/fd/1 ] || exec 1>&9
[ -e /dev/fd/2 ] || exec 2>&9

# `exename` is used to behave differently depending on how we are symlinked.
# `exepath` is printed in usage text and mimics other CLIs' output text.
exename=${0##*'/'}
exepath=$(command -v -- "${exename}" && printf 'n') && [ "${exepath%?}" = "${0}" ]
if [ "${?}" -eq 0 ]; then
    exepath=${exename}
else
    exepath=${0}
fi
exename=${exename%'.sh'}

# Handle invocation with zero arguments as well as --version.
case "${exename}${1+' '}${1-}${2+' '}" in
    'kzdl')
        printf 'Usage: %s [command] [options]\n%s\n' "${exepath}" \
            "See \`${exepath} --help\` for detailed usage information" >&2
        exit 1 ;;
    'kzdl --version' | 'kzdl -V')
        printf '%s\n' "${ver}"
        exit ;;
esac

# Check for required dependencies; print error if any are missing.
type jq cat mktemp mkfifo rm >&9 || {
    message='kzdl: Missing dependencies:'
    for dep in \
        'jq - used for manipulating data and config' \
        'cat - required for piping file contents' \
        'mktemp - required to store temporary files' \
        'mkfifo - required to create named pipes' \
        'rm - required to clean up temporary state'
    do
        type "${dep%%' - '*}" >&9 && continue
        message=$(printf '%s\n  %s' "${message}" "${dep}")
    done
    printf '%s\n' "${message}" >&2
    exit 1
}

# Set up our temporary environment and jq communication pipes.
set -e
trap 'exec 3<&-; wait; rm -rf -- "${tmpdir}"; exit 130' INT
trap 'exec 3<&-; wait; rm -rf -- "${tmpdir}"; exit 143' TERM
tmpdir=$(mktemp -d)
jq_stdin="${tmpdir}/jq_stdin"
jq_stdout="${tmpdir}/jq_stdout"
mkfifo -- "${jq_stdin}" "${jq_stdout}"

# zzz parsing library (so we can read user config file).
cat <<'EOF' >"${tmpdir}/zzz.jq"
    # Given a ztree as input, return the value at $zpath.
    def zget($zpath):
        objects // error("zzz parser bug: ztree is not object")
        | getpath($zpath|map("children", .));
    def zget(ztree; $zpath):
        ztree | zget($zpath);

    # Given a ztree as input, return the number of children it has.
    def zlen($zpath):
        zget($zpath).children | length;
    def zlen(ztree; $zpath):
        ztree | zlen($zpath);

    # Given a ztree as input, set the value at the provided zpath.
    def zset($zpath; $value):
        ($zpath|map("children", .)) as $zpath
        | setpath($zpath;
            getpath($zpath)
            | .value = $value
            | .children //= []
        );
    def zset(ztree; $zpath; $value):
        ztree |= zset($zpath; $value);

    # Parse the input zzz data into a tree of strings.
    def parse_zzz($filename):
        "#[=]:;, \"\n\t\r" as $special      |
        ($special|explode) as $special      |
        $special[0] as $comment             |
        $special[1] as $open_multiline      |
        $special[2] as $extend_multiline    |
        $special[3] as $close_multiline     |
        $special[4] as $traverse_child      |
        $special[5] as $traverse_parent     |
        $special[6] as $traverse_sibling    |
        $special[7] as $whitespace          |
        $special[8] as $string_quote        |
        $special[9] as $newline             |
        $special[10:] as $invalid           |
        $special[4:7] as $traverse          |
        [$special[9],"EOF"] as $endline     |
        ($traverse+$endline) as $endtoken   |
        ($endtoken+[$comment]) as $endtoken |

        # Print an error with the given message and line/column information.
        . as $buf |
        def zerr($msg):
            error(
                "\n  \($filename):\(.line):\(.col): error: \($msg)\n  " +
                first($buf[(.index - .col + 1):]|splits("\\n")) + "\n \(" " * .col)^"
            );

        # Parse the zzz file as a stream of codepoints.
        reduce (explode[], "EOF") as $char (
            {
                # The tree of nodes, eventually extracted as the final result.
                tree: {value: null, children: []},
                # The zpath of the node we're currently working with.
                path: [],
                # The zpath to the root of the previous line.
                root: [],
                # The current state of the parser (defaults to start of line).
                state: "open_line",
                # How deep into the tree we are indentation-wise.
                indent: 0,
                # The current byte index into the buffer.
                index: 0,
                # The current line and column numbers.
                line: 1, col: 1,
            };
            def parse:
                def open_line:
                    .state = "open_line" | .indent = 0;
                def open_indent:
                    .state = "open_indent";
                def read_token:
                    .state = "read_token";
                def open_comment:
                    .state = "open_comment";
                def open_multiline:
                    .state = "open_multiline" | .extend = 0 | .nest = 0;
                def multiline_start:
                    .state = "multiline_start";
                def multiline_text:
                    .state = "multiline_text";
                def nest_multiline:
                    .state = "nest_multiline" | .count = 0;
                def close_multiline:
                    .state = "close_multiline" | .count = 0;
                def open_string:
                    .state = "open_string" | .start = .index + 1;
                def open_literal:
                    .state = "open_literal" | .start = .index | .trailing = 0;
                def end_string:
                    .state = "end_string";
                def traverse_child:
                    .state = "traverse_child";
                def traverse_parent:
                    select(.path | length > 1) // zerr("cannot select parent of root") |
                    .state = "traverse_parent" | .path |= .[:-1];
                def traverse_sibling:
                    .state = "traverse_sibling";

                if .state == "open_line" then
                    if $char == $whitespace then
                        open_indent
                    elif ($endline|any(. == $char)) then
                        open_line
                    elif ($invalid|any(. == $char)) then
                        zerr("invalid whitespace")
                    elif .indent > (.root|length) then
                        zerr("too much indentation")
                    elif $char == $comment then
                        .root = .root[:.indent]
                        | open_comment
                    elif $char == $traverse_parent then
                        .root = .root[:.indent]
                        | .path = .root
                        | traverse_parent
                    else
                        .root = .root[:.indent]
                        | .root += [zlen(.tree; .root)]
                        | zset(.tree; .root; null)
                        | .path = .root
                        | read_token
                        | parse
                    end
                elif .state == "open_indent" then
                    if $char == $whitespace then
                        .indent += 1 | .state = "open_line"
                    else
                        zerr("odd number of spaces")
                    end
                elif .state == "read_token" then
                    if ($invalid|any(. == $char)) then
                        zerr("invalid whitespace")
                    elif ($endline|any(. == $char)) then
                        open_line
                    elif $char == $traverse_child then
                        traverse_child
                    elif $char == $traverse_parent then
                        traverse_parent
                    elif $char == $traverse_sibling then
                        traverse_sibling
                    elif $char == $open_multiline then
                        open_multiline
                    elif $char == $string_quote then
                        open_string
                    elif $char == $comment then
                        open_comment
                    else
                        open_literal
                    end
                elif .state == "open_comment" then
                    if $char == $newline then
                        open_line
                    else . end
                elif .state == "open_multiline" then
                    if $char == $extend_multiline then
                        .extend += 1
                    elif $char == $open_multiline then
                        multiline_start
                    elif $char == "EOF" then
                        zerr("unexpected end of file in multiline literal")
                    elif $char == $newline then
                        zerr("unexpected newline in multiline delimiter")
                    else
                        zerr("unexpected character in multiline delimiter")
                    end
                elif .state == "multiline_start" then
                    multiline_text |
                    if $char == $newline then
                        .start = .index + 1
                    else
                        .start = .index | parse
                    end
                elif .state == "multiline_text" then
                    if $char == $open_multiline then
                        nest_multiline
                    elif $char == $close_multiline then
                        close_multiline
                    elif $char == "EOF" then
                        zerr("unexpected end of file in multiline literal")
                    else . end
                elif .state == "nest_multiline" then
                    if $char == $extend_multiline then
                        .count += 1
                    elif ($char == $open_multiline and .count == .extend) then
                        .nest += 1 | multiline_text
                    else
                        multiline_text | parse
                    end
                elif .state == "close_multiline" then
                    if $char == $extend_multiline then
                        .count += 1
                    elif ($char == $close_multiline and .count == .extend) then
                        if .nest == 0 then
                            zset(.tree; .path; $buf[.start:(.index - .extend - 1)]) | end_string
                        else
                            .nest -= 1 | multiline_text
                        end
                    else
                        multiline_text | parse
                    end
                elif .state == "open_string" then
                    if $char == $string_quote then
                        zset(.tree; .path; $buf[.start:.index]) | end_string
                    elif $char == $newline then
                        zerr("unexpected newline in quoted string")
                    elif $char == "EOF" then
                        zerr("unexpected end of file in quoted string")
                    else . end
                elif .state == "open_literal" then
                    if $char == $whitespace then
                        .trailing += 1
                    elif ($invalid|any(. == $char)) then
                        zerr("invalid whitespace")
                    elif ($endtoken|any(. == $char)) then
                        zset(.tree; .path; $buf[.start:(.index - .trailing)])
                        | read_token
                        | parse
                    else
                        .trailing = 0
                    end
                elif .state == "end_string" then
                    if ($endtoken|any(. == $char)) then
                        read_token | parse
                    elif ($invalid|any(. == $char)) then
                        zerr("invalid whitespace")
                    elif $char != $whitespace then
                        zerr("unexpected character after string")
                    else . end
                elif .state == "traverse_child" then
                    if ($invalid|any(. == $char)) then
                        zerr("invalid whitespace")
                    elif ($endline|any(. == $char)) then
                        open_line
                    elif $char == $comment then
                        open_comment
                    elif $char != $whitespace then
                        .path += [zlen(.tree; .path)]
                        | zset(.tree; .path; null)
                        | read_token
                        | parse
                    else . end
                elif .state == "traverse_parent" then
                    if ($invalid|any(. == $char)) then
                        zerr("invalid whitespace")
                    elif ($endline|any(. == $char)) then
                        open_line
                    elif $char == $comment then
                        open_comment
                    elif $char == $traverse_parent then
                        traverse_parent
                    elif $char != $whitespace then
                        .path[-1] += 1
                        | zset(.tree; .path; null)
                        | read_token
                        | parse
                    else . end
                elif .state == "traverse_sibling" then
                    if ($invalid|any(. == $char)) then
                        zerr("invalid whitespace")
                    elif ($endline|any(. == $char)) then
                        open_line
                    elif $char == $comment then
                        open_comment
                    elif $char != $whitespace then
                        .path[-1] += 1
                        | zset(.tree; .path; null)
                        | read_token
                        | parse
                    else . end
                else
                    zerr("zzz parser bug: unknown state \(.state)")
                end;
            parse | .index += 1 |
            if $char == $newline then
                .line += 1 | .col = 1
            else
                .col += 1
            end
        ) | .tree;
    def parse_zzz:
        parse_zzz("<unknown>");
EOF

# Start jq background process, allowing it to drive further execution.
jq -Rr -L "${tmpdir}" --unbuffered \
    --from-file /dev/fd/3 \
    --arg exename "${exename}" \
    --arg exepath "${exepath}" \
    --arg tmp "${tmpdir}" \
    --arg ver "${ver}" \
    --args -- "${@}" \
    <"${jq_stdin}" >"${jq_stdout}" 3<<'JQ_SCRIPT' &
    import "zzz" as ZZZ;

    { args: $ARGS.positional } |

    # Run the requested filter only for non-string inputs.
    def N(f):
        strings // f;

    # Read an input, halting with an error if this is not possible.
    def try_input:
        "Interrupted!\n" | input? // halt_error(1);

    # Read the output of `cat -n` as a stream of lines.
    def read_lines:
        try_input | while(length >= 1; try_input) | sub("^ *\\d+\\t"; "");

    # Generate shell-escaped printf command argv.
    def printf:
        reduce
            capture("(?<nul>\\0)|(?<newline>\\n)|(?<str>[^\\0\\n]+)"; "g")
        as $capture (
            [""]; first(
                (select($capture.nul) | .[0] += "\\0"),
                (select($capture.newline) | .[0] += "\\n"),
                (.[0] += "%s") + [$capture.str|@sh]
            )
        ) | .[0] |= @sh;

    # Run the input shell command; set `.status` to its exit status.
    def cmd_status($cmd):
        $cmd, @sh "printf \("%s\\n") \"${?}\" >&3",
        .status = (try_input|tonumber);

    # Run the input shell command; set `.output` to stdout and `.status` to exit status.
    def cmd_output($cmd):
        "{ { \($cmd)\n
                printf \("\\n%s\\n"|@sh) \"${?}\"
            } | cat -n; printf \("\\n"|@sh)
        } >&3", (
            . + reduce read_lines as $line ({};
                (.output|values) += "\n"
                | .output += .status
                | .status = $line
            ) | .status |= tonumber
        );

    # Check whether $cmd exists in ${PATH}; set `.exists` to the result.
    def require_cmd($cmd):
        cmd_status(@sh "type \($cmd) >&9") | N(.exists = .status == 0);

    # Prompt the user to enter 'y' or 'n'; set `.confirm` to the result.
    def prompt_user($default; $prompt):
        (
            if $default then " [Y/n] " else " [y/N] " end |
            @sh "{
                response=yes
                [ -t 0 ] && {
                    printf \("%s") \($prompt + .) >&2
                    IFS= read -r response
                }
                printf \("%s\\n") \"${response}\" >&3
            } <&7"
        ), (
            .confirm = (
                input? // ("\nInterrupted!\n"|halt_error(1)) |
                first(
                    (select(length == 0)|$default),
                    (test("^no*$"; "i")|select(.)|not),
                    test("^y(?:es?)?$"; "i") // null
                )
            )
        );

    # Shorthands of the above to provide useful defaults.
    def prompt_user($default):
        prompt_user($default; "Do you wish to continue?");
    def prompt_user:
        prompt_user(true);

    # Store the current OS and architecture in `.system`.
    def get_system:
        require_cmd("uname") | N(
            if .exists then
                cmd_output("uname")
                | N(
                    def case($a; f):
                        select(startswith($a))|$a|f;
                    .system = {
                        os: first(
                            .output[:-1] |
                            case("Linux", "Windows", "NetBSD", "FreeBSD", "OpenBSD"; ascii_downcase),
                            case("MSYS", "MINGW", "CYGWIN"; "windows"),
                            case("DragonFly"; "dragonflybsd"),
                            case("SunOS"; "solaris"),
                            null
                        )
                    }
                )
                | N(cmd_output("uname -m"))
                | N(
                    def case($a; f):
                        select(test($a; "i"))|f;
                    .system.arch = first(
                        .output[:-1] |
                        case("^(?:x86_64|amd64)$"; "x86_64"),
                        case("^(?:x86|i386|i686|i86pc)$"; "i386"),
                        case("^(?:aarch64|riscv64|sparc(?:v9)?)$"; ascii_downcase),
                        case("^armv6"; "armv6kz"),
                        case("^armv7"; "armv7a"),
                        case("^sparc64$"; "sparcv9"),
                        case("^sun4u$"; "sparc"),
                        null
                    )
                )
                | N(.system |= (.double = "\(.arch)-\(.os)"))
            else
                .system = {os: null, arch: null, double: null}
            end
        );

    # Script entry point; current just a testbed for the above functions.
    def main:
        get_system | N(prompt_user) | N(
            if .confirm then
                @sh "printf \("Your system is: %s\\n") \(.system.double) >&2"
            else
                @sh "printf \("Canceled!\\n") >&2"
            end
        );
    main, "exec 3<&-" | printf | join(" ")
JQ_SCRIPT
exec 3>"${jq_stdin}"
printf '\n' >&3
set +e

# Eval everything the jq script tells us to.
status=0
while IFS= read -r evalstr; do
    eval 'eval "$(printf '"${evalstr}"')"'
done 7<&0 <"${jq_stdout}"

# Clean up temporary directory and exit as appropriate.
rm -rf -- "${tmpdir}"
exit "${status}"
